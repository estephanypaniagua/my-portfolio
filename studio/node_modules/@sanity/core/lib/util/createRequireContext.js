"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRequireContext = createRequireContext;

var _path = _interopRequireDefault(require("path"));

var _klawSync = _interopRequireDefault(require("klaw-sync"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const globalRequire = require;

function createRequireContext(dirname, {
  require = globalRequire,
  resolve = globalRequire.resolve.bind(globalRequire)
} = {}) {
  function requireContext(directory, recursive = true, regExp = /.*/) {
    console.warn('Usage of `require.context` is deprecated and will break in a future release.');

    try {
      const basedir = _path.default.resolve(dirname, directory);

      const keys = (0, _klawSync.default)(basedir, {
        depthLimit: recursive ? 30 : 0
      }).filter(item => !item.stats.isDirectory() && regExp.test(item.path)) // use relative paths for the keys
      .map(item => _path.default.relative(basedir, item.path)) // if the path.resolve doesn't prefixed with `./` then add it.
      // note it could be upward `../` so we need the conditional
      .map(filename => filename.startsWith('.') ? filename : `./${filename}`); // eslint-disable-next-line no-inner-declarations

      function context(request) {
        // eslint-disable-next-line import/no-dynamic-require
        return require(_path.default.join(basedir, request));
      }

      Object.defineProperty(context, 'id', {
        get: () => {
          console.warn('`require.context` `context.id` is not supported.');
          return '';
        }
      });
      Object.defineProperty(context, 'keys', {
        // NOTE: this keys method does not match the behavior of webpack's
        // require.context context because it does not return all possible keys
        //
        // e.g. `./module-a/index.js`
        // would return `['./module-a', './module-a/index', './module-a/index.js']`
        value: () => keys
      });
      Object.defineProperty(context, 'resolve', {
        value: request => resolve(_path.default.join(basedir, request))
      });
      return context;
    } catch (contextErr) {
      contextErr.message = `Error running require.context():\n\n${contextErr.message}`;
      throw contextErr;
    }
  }

  return requireContext;
}