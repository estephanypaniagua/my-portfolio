"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IntentResolver = void 0;

var _ui = require("@sanity/ui");

var _uuid = require("@sanity/uuid");

var _hooks = require("@sanity/base/hooks");

var _initialValueTemplates = require("@sanity/base/initial-value-templates");

var _react = _interopRequireWildcard(require("react"));

var _constants = require("../../constants");

var _resolvePanes = require("../../utils/resolvePanes");

var _useUnique = require("../../utils/useUnique");

var _Delay = require("../Delay");

var _StructureError = require("../StructureError");

var _Redirect = require("./Redirect");

var _utils = require("./utils");

var _excluded = ["type", "id"],
    _excluded2 = ["template"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var FALLBACK_ID = '__fallback__';
/**
 *
 * This is a *very naive* implementation of an intent resolver:
 * - If type is missing from params, it'll try to resolve from document
 * - It manually builds a pane segment path: "<typeName>;<documentId>"
 * - Tries to resolve that to a structure
 * - Checks if the last pane segment is an editor, and if so; is it the right type/id?
 *   - Yes: Resolves to "<typeName>;<documentId>"
 *   - No : Resolves to fallback edit pane (context-less)
 */

var IntentResolver = /*#__PURE__*/_react.default.memo(function IntentResolver(_ref) {
  var params = _ref.params,
      payload = _ref.payload;

  var _ref2 = params || {},
      specifiedSchemaType = _ref2.type,
      id = _ref2.id,
      otherParamsNonUnique = _objectWithoutProperties(_ref2, _excluded);

  var otherParams = (0, _useUnique.useUnique)(otherParamsNonUnique);
  var documentId = id || FALLBACK_ID;

  var _useDocumentType = (0, _hooks.useDocumentType)(documentId, specifiedSchemaType),
      documentType = _useDocumentType.documentType,
      isLoaded = _useDocumentType.isLoaded;

  var paneSegments = (0, _react.useMemo)(() => {
    if (!documentType) return undefined;
    var filteredParams = Object.fromEntries(Object.entries(otherParams).filter(entry => typeof entry[1] === 'string'));
    return [[{
      id: documentType,
      params: filteredParams
    }], [{
      id: documentId,
      params: filteredParams,
      payload
    }]];
  }, [documentId, documentType, otherParams, payload]);

  var _useStructure = (0, _resolvePanes.useStructure)(paneSegments, {
    silent: true
  }),
      structure = _useStructure.structure,
      error = _useStructure.error;

  var isLoading = Boolean(!structure || structure.some(item => item === _constants.LOADING_PANE));
  var panes = (0, _react.useMemo)(() => {
    if (error) return null;
    if (!documentType) return null;
    if (isLoading) return null;
    if (!paneSegments) return null;
    var lastChild = structure === null || structure === void 0 ? void 0 : structure[structure.length - 1];
    var lastGroup = paneSegments[paneSegments.length - 1];
    var lastSibling = lastGroup[lastGroup.length - 1];
    var terminatesInDocument = lastChild && typeof lastChild === 'object' && lastChild.type === 'document' && lastChild.options.id === documentId;

    var isTemplateCreate = otherParams.template,
        _otherParams = _objectWithoutProperties(otherParams, _excluded2);

    var template = isTemplateCreate && (0, _initialValueTemplates.getTemplateById)(otherParams.template);
    var type = template && template.schemaType || documentType;

    var fallbackParameters = _objectSpread(_objectSpread({}, _otherParams), {}, {
      type,
      template: otherParams.template
    });

    var newDocumentId = documentId === FALLBACK_ID ? (0, _uuid.uuid)() : (0, _utils.removeDraftPrefix)(documentId);
    return terminatesInDocument ? paneSegments.slice(0, -1).concat([lastGroup.slice(0, -1).concat(_objectSpread(_objectSpread({}, lastSibling), {}, {
      id: newDocumentId
    }))]) : [[{
      id: "__edit__".concat(newDocumentId),
      params: fallbackParameters,
      payload
    }]];
  }, [documentId, documentType, error, isLoading, otherParams, paneSegments, payload, structure]);
  var nonDocumentTypePanes = (0, _react.useMemo)(() => [[{
    id: "__edit__".concat(id || (0, _uuid.uuid)()),
    params: Object.fromEntries(Object.entries(otherParams).filter(entry => typeof entry[1] === 'string'))
  }]], [id, otherParams]);

  if (error) {
    return /*#__PURE__*/_react.default.createElement(_StructureError.StructureError, {
      error: error
    });
  }

  if (!documentType) {
    if (isLoaded) {
      return /*#__PURE__*/_react.default.createElement(_Redirect.Redirect, {
        panes: nonDocumentTypePanes
      });
    }

    return /*#__PURE__*/_react.default.createElement(_ui.Card, {
      height: "fill"
    }, /*#__PURE__*/_react.default.createElement(_Delay.Delay, {
      ms: 300
    }, /*#__PURE__*/_react.default.createElement(_ui.Flex, {
      align: "center",
      direction: "column",
      height: "fill",
      justify: "center"
    }, /*#__PURE__*/_react.default.createElement(_ui.Spinner, {
      muted: true
    }), /*#__PURE__*/_react.default.createElement(_ui.Box, {
      marginTop: 3
    }, /*#__PURE__*/_react.default.createElement(_ui.Text, {
      align: "center",
      muted: true,
      size: 1
    }, "Resolving document type\u2026")))));
  }

  if (isLoading) {
    return /*#__PURE__*/_react.default.createElement(_ui.Card, {
      height: "fill"
    }, /*#__PURE__*/_react.default.createElement(_Delay.Delay, {
      ms: 300
    }, /*#__PURE__*/_react.default.createElement(_ui.Flex, {
      align: "center",
      direction: "column",
      height: "fill",
      justify: "center"
    }, /*#__PURE__*/_react.default.createElement(_ui.Spinner, {
      muted: true
    }), /*#__PURE__*/_react.default.createElement(_ui.Box, {
      marginTop: 3
    }, /*#__PURE__*/_react.default.createElement(_ui.Text, {
      muted: true,
      size: 1
    }, "Resolving structure\u2026")))));
  }

  return panes ? /*#__PURE__*/_react.default.createElement(_Redirect.Redirect, {
    panes: panes
  }) : null;
});

exports.IntentResolver = IntentResolver;