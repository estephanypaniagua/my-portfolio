"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DeskTool = DeskTool;

var _initialValueTemplates = require("@sanity/base/initial-value-templates");

var _router = require("@sanity/base/router");

var _ui = require("@sanity/ui");

var _react = _interopRequireWildcard(require("react"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _pane = require("./components/pane");

var _StructureError = require("./components/StructureError");

var _constants = require("./constants");

var _deskTool = require("./contexts/deskTool");

var _getPanes = require("./getPanes");

var _helpers = require("./helpers");

var _panes2 = require("./panes");

var _resolvePanes = require("./utils/resolvePanes");

var _excluded = ["template"];

var _templateObject;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var StyledPaneLayout = (0, _styledComponents.default)(_pane.PaneLayout)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  min-height: 100%;\n  min-width: 320px;\n"])));
/**
 * @internal
 */

function DeskTool(props) {
  var onPaneChange = props.onPaneChange;

  var _useToast = (0, _ui.useToast)(),
      pushToast = _useToast.push;

  var _useRouter = (0, _router.useRouter)(),
      navigate = _useRouter.navigate;

  var routerState = (0, _router.useRouterState)();
  var routerPanes = (0, _react.useMemo)(() => (routerState === null || routerState === void 0 ? void 0 : routerState.panes) || [], [routerState === null || routerState === void 0 ? void 0 : routerState.panes]);

  var _useState = (0, _react.useState)(null),
      _useState2 = _slicedToArray(_useState, 2),
      error = _useState2[0],
      setError = _useState2[1];

  var prevRouterPanesRef = (0, _react.useRef)(null);
  var currRouterPanesRef = (0, _react.useRef)(routerPanes);

  var _useState3 = (0, _react.useState)(false),
      _useState4 = _slicedToArray(_useState3, 2),
      layoutCollapsed = _useState4[0],
      setLayoutCollapsed = _useState4[1];

  var _useState5 = (0, _react.useState)([]),
      _useState6 = _slicedToArray(_useState5, 2),
      resolvedPanes = _useState6[0],
      setResolvedPanes = _useState6[1];

  var resolvedPanesRef = (0, _react.useRef)(resolvedPanes);

  var _useState7 = (0, _react.useState)(null),
      _useState8 = _slicedToArray(_useState7, 2),
      portalElement = _useState8[0],
      setPortalElement = _useState8[1];

  var structure$Ref = (0, _react.useRef)(null);

  var _ref = routerState || {},
      action = _ref.action,
      legacyEditDocumentId = _ref.legacyEditDocumentId,
      schemaType = _ref.type,
      editDocumentId = _ref.editDocumentId,
      _ref$params = _ref.params,
      params = _ref$params === void 0 ? {} : _ref$params;

  var panes = (0, _react.useMemo)(() => (0, _getPanes.getPanes)(resolvedPanes, routerPanes), [resolvedPanes, routerPanes]);
  var setResolveError = (0, _react.useCallback)(_error => {
    (0, _resolvePanes.setStructureResolveError)(_error); // Log error for proper stack traces

    console.error(_error); // eslint-disable-line no-console

    setError(_error);
  }, []);
  var handleRootCollapse = (0, _react.useCallback)(() => setLayoutCollapsed(true), []);
  var handleRootExpand = (0, _react.useCallback)(() => setLayoutCollapsed(false), []); // Load the structure configuration observable

  (0, _react.useEffect)(() => {
    structure$Ref.current = (0, _resolvePanes.loadStructure)().pipe((0, _operators.distinctUntilChanged)(), (0, _operators.map)(_resolvePanes.maybeSerialize));
    return () => {
      structure$Ref.current = null;
    };
  }, []); // The pane layout is "collapsed" on small screens, and only shows 1 pane at a time.
  // Remove pane siblings (i.e. split panes) as the pane layout collapses.

  (0, _react.useEffect)(() => {
    if (!layoutCollapsed) {
      return;
    }

    var hasSiblings = routerPanes.some(group => group.length > 1);

    if (!hasSiblings) {
      return;
    }

    var withoutSiblings = routerPanes.map(group => [group[0]]);
    navigate({
      panes: withoutSiblings
    }, {
      replace: true
    });
  }, [navigate, layoutCollapsed, routerPanes]); // Handle old-style URLs

  (0, _react.useEffect)(() => {
    var templateName = params.template,
        payloadParams = _objectWithoutProperties(params, _excluded);

    var template = (0, _initialValueTemplates.getTemplateById)(templateName);
    var type = template && template.schemaType || schemaType;
    var shouldRewrite = action === 'edit' && legacyEditDocumentId || type && editDocumentId;

    if (!shouldRewrite) {
      return;
    }

    navigate((0, _helpers.getIntentRouteParams)({
      id: editDocumentId || legacyEditDocumentId,
      type,
      payloadParams,
      templateName
    }), {
      replace: true
    });
  }, [action, editDocumentId, legacyEditDocumentId, navigate, params, schemaType]);
  (0, _react.useEffect)(() => {
    var handleGlobalKeyDown = event => {
      // Prevent `Cmd+S`
      if ((0, _helpers.isSaveHotkey)(event)) {
        event.preventDefault();
        pushToast({
          closable: true,
          id: 'auto-save-message',
          status: 'info',
          title: 'Sanity auto-saves your work!',
          duration: 4000
        });
      }
    };

    window.addEventListener('keydown', handleGlobalKeyDown);
    return () => {
      window.removeEventListener('keydown', handleGlobalKeyDown);
    };
  }, [pushToast]);
  (0, _react.useEffect)(() => {
    prevRouterPanesRef.current = currRouterPanesRef.current;
    currRouterPanesRef.current = routerPanes;
  }, [routerPanes]);
  (0, _react.useEffect)(() => {
    var structure$ = structure$Ref.current;
    if (!structure$) return undefined;
    var _resolvedPanes = resolvedPanesRef.current;
    var prevPanes = prevRouterPanesRef.current;
    var nextPanes = currRouterPanesRef.current;
    var fromIndex = (0, _helpers.getPaneDiffIndex)(nextPanes, prevPanes) || [0, 0];
    var resolvedPanes$ = structure$.pipe((0, _operators.switchMap)(structure => (0, _resolvePanes.resolvePanes)(structure, routerPanes, _resolvedPanes, fromIndex)), (0, _operators.switchMap)(_panes => (0, _helpers.hasLoading)(_panes) ? (0, _rxjs.of)(_panes).pipe((0, _operators.debounce)(() => (0, _rxjs.interval)(50))) : (0, _rxjs.of)(_panes)));
    var sub = resolvedPanes$.subscribe({
      next(value) {
        setResolvedPanes(value);
        resolvedPanesRef.current = value;
      },

      error(err) {
        setResolveError(err);
      }

    });
    return () => sub.unsubscribe();
  }, [routerPanes, setResolveError, setResolvedPanes]);
  (0, _react.useEffect)(() => onPaneChange(resolvedPanes), [onPaneChange, resolvedPanes]);
  var children = (0, _react.useMemo)(() => {
    if (panes.length === 0) return null;
    return panes.map(paneData => {
      var active = paneData.active,
          childItemId = paneData.childItemId,
          groupIndex = paneData.groupIndex,
          itemId = paneData.itemId,
          paneKey = paneData.key,
          pane = paneData.pane,
          paneIndex = paneData.index,
          paneParams = paneData.params,
          path = paneData.path,
          payload = paneData.payload,
          siblingIndex = paneData.siblingIndex,
          selected = paneData.selected;

      if (pane === _constants.LOADING_PANE) {
        return /*#__PURE__*/_react.default.createElement(_panes2.LoadingPane, {
          key: "loading-".concat(paneIndex),
          path: path,
          index: paneIndex,
          message: _helpers.getWaitMessages,
          selected: selected
        });
      }

      return /*#__PURE__*/_react.default.createElement(_panes2.DeskToolPane, {
        active: active,
        groupIndex: groupIndex,
        index: paneIndex,
        key: "".concat(pane.type, "-").concat(paneIndex),
        pane: pane,
        childItemId: childItemId,
        itemId: itemId,
        paneKey: paneKey,
        params: paneParams,
        payload: payload,
        selected: selected,
        siblingIndex: siblingIndex
      });
    });
  }, [panes]);
  return (0, _react.useMemo)(() => {
    if (error) {
      return /*#__PURE__*/_react.default.createElement(_StructureError.StructureError, {
        error: error
      });
    }

    return /*#__PURE__*/_react.default.createElement(_deskTool.DeskToolProvider, {
      layoutCollapsed: layoutCollapsed
    }, /*#__PURE__*/_react.default.createElement(_ui.PortalProvider, {
      element: portalElement || null
    }, /*#__PURE__*/_react.default.createElement(StyledPaneLayout, {
      flex: 1,
      height: layoutCollapsed ? undefined : 'fill',
      minWidth: 512,
      onCollapse: handleRootCollapse,
      onExpand: handleRootExpand
    }, children), /*#__PURE__*/_react.default.createElement("div", {
      "data-portal": "",
      ref: setPortalElement
    })));
  }, [children, error, handleRootCollapse, handleRootExpand, layoutCollapsed, portalElement]);
}